// Copyright 2021 Tencent Inc. All rights reserved.
//
// 服务商批量转账API
//
// No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
//
// API version: 0.0.3

// Code generated by WechatPay APIv3 Generator based on [OpenAPI Generator](https://openapi-generator.tech); DO NOT EDIT.

package partnertransferbatch

import (
	"encoding/json"
	"fmt"
	"time"
)

// AuthType   INFORMATION_AUTHORIZATION_TYPE - 特约商户信息授权类型，表示使用特约商户用户信息，出款方服务商  FUND_AUTHORIZATION_TYPE - 特约商户资金授权类型，表示使用特约商户的资金，出款方为特约商户，用户信息为服务商appid对应的openid  INFORMATION_AND_FUND_AUTHORIZATION_TYPE - 特约商户信息和资金授权类型，表示使用特约商户的用户信息且出款方为特约商户
type AuthType string

func (e AuthType) Ptr() *AuthType {
	return &e
}

// Enums of AuthType
const (
	AUTHTYPE_INFORMATION_AUTHORIZATION_TYPE          AuthType = "INFORMATION_AUTHORIZATION_TYPE"
	AUTHTYPE_FUND_AUTHORIZATION_TYPE                 AuthType = "FUND_AUTHORIZATION_TYPE"
	AUTHTYPE_INFORMATION_AND_FUND_AUTHORIZATION_TYPE AuthType = "INFORMATION_AND_FUND_AUTHORIZATION_TYPE"
)

// CloseReasonType   MERCHANT_REVOCATION - 商户主动撤销，商户主动撤销（页面方式）  OVERDUE_CLOSE - 系统超时关闭，系统超时关闭，可能原因账户余额不足或其他错误
type CloseReasonType string

func (e CloseReasonType) Ptr() *CloseReasonType {
	return &e
}

// Enums of CloseReasonType
const (
	CLOSEREASONTYPE_MERCHANT_REVOCATION CloseReasonType = "MERCHANT_REVOCATION"
	CLOSEREASONTYPE_OVERDUE_CLOSE       CloseReasonType = "OVERDUE_CLOSE"
)

// FailReasonType   ACCOUNT_FROZEN - 账户冻结，该用户账户被冻结  REAL_NAME_CHECK_FAIL - 用户未实名，收款人未实名认证，需要用户完成微信实名认证  NAME_NOT_CORRECT - 用户姓名校验失败，收款人姓名校验不通过，请核实信息  OPENID_INVALID - Openid校验失败，Openid格式错误或者不属于商家公众账号  TRANSFER_QUOTA_EXCEED - 超过用户单笔收款额度，超过用户单笔收款额度，核实产品设置是否准确  DAY_RECEIVED_QUOTA_EXCEED - 超过用户单日收款额度，超过用户单日收款额度，核实产品设置是否准确  MONTH_RECEIVED_QUOTA_EXCEED - 超过用户单月收款额度，超过用户单月收款额度，核实产品设置是否准确  DAY_RECEIVED_COUNT_EXCEED - 超过用户单日收款次数，超过用户单日收款次数，核实产品设置是否准确  PRODUCT_AUTH_CHECK_FAIL - 产品权限校验失败，未开通该权限或权限被冻结，请核实产品权限状态  OVERDUE_CLOSE - 转账关闭，超过系统重试期，系统自动关闭  ID_CARD_NOT_CORRECT - 用户身份证校验失败，收款人身份证校验不通过，请核实信息  ACCOUNT_NOT_EXIST - 用户账户不存在，该用户账户不存在  TRANSFER_RISK - 转账存在风险，该笔转账可能存在风险，已被微信拦截  PAYROLL_CARD_ALREADY_LOGOUT - 用户务工卡已注销，该用户的务工卡已经注销  PAYROLL_CARD_ALREADY_FROZEN - 用户务工卡已冻结，该用户的务工卡已经被冻结  PAYROLL_CARD_UNAUTHORIZED - 用户务工卡未授权该商户，该用户的务工卡未授权该商户  PAYROLL_CARD_USER_NOT_OPEN - 用户未开通务工卡，该用户没有开通务工卡  PAYROLL_CARD_NAME_CARD_NOT_MATCH - 用户姓名与务工卡实名不一致，务工卡实名和用户实名不一致  PAYROLL_CARD_ID_CARD_NOT_MATCH - 用户身份证与务工卡身份证不一致，务工卡身份证和用户身份证不一致  PAYROLL_CARD_BANKCARD_UNBUNDLING - 用户务工卡所选银行卡已解绑，务工卡所选银行卡已解绑  BANK_CARD_COLLECTIONS_ABOVE_QUOTA - 银行卡收款超过限额，银行卡属二/三类卡，达到收款限额无法入账  BANK_CARD_ACCOUNT_ABNORMAL - 银行卡账户异常，银行卡已被销户、冻结、作废、挂失等致无法入账  BANK_CARD_STATUS_ABNORMAL - 银行卡状态异常，银行卡状态异常，无法入账  BANK_CARD_BANK_INFO_WRONG - 银行卡银行信息错误，登记的银行名称或分支行信息有误  BANK_CARD_CARD_INFO_WRONG - 银行卡户名或卡号错误，银行卡户名或卡号有误  OTHER_FAIL_REASON_TYPE - 其它失败，其它失败原因  REALNAME_ACCOUNT_RECEIVED_QUOTA_EXCEED - 用户账户收款受限，请引导用户在微信支付查看详情  RECEIVE_ACCOUNT_NOT_PERMMIT - 未配置该用户为转账收款人，请在产品设置中调整，添加该用户为收款人  PAYEE_ACCOUNT_ABNORMAL - 用户账户收款异常，请联系用户完善其在微信支付的身份信息以继续收款  PAYER_ACCOUNT_ABNORMAL - 商户账户付款受限，可前往商户平台获取解除功能限制指引  TRANSFER_REMARK_SET_FAIL - 转账备注设置失败，转账备注设置失败，请调整后重新再试
type FailReasonType string

func (e FailReasonType) Ptr() *FailReasonType {
	return &e
}

// Enums of FailReasonType
const (
	FAILREASONTYPE_ACCOUNT_FROZEN                         FailReasonType = "ACCOUNT_FROZEN"
	FAILREASONTYPE_REAL_NAME_CHECK_FAIL                   FailReasonType = "REAL_NAME_CHECK_FAIL"
	FAILREASONTYPE_NAME_NOT_CORRECT                       FailReasonType = "NAME_NOT_CORRECT"
	FAILREASONTYPE_OPENID_INVALID                         FailReasonType = "OPENID_INVALID"
	FAILREASONTYPE_TRANSFER_QUOTA_EXCEED                  FailReasonType = "TRANSFER_QUOTA_EXCEED"
	FAILREASONTYPE_DAY_RECEIVED_QUOTA_EXCEED              FailReasonType = "DAY_RECEIVED_QUOTA_EXCEED"
	FAILREASONTYPE_MONTH_RECEIVED_QUOTA_EXCEED            FailReasonType = "MONTH_RECEIVED_QUOTA_EXCEED"
	FAILREASONTYPE_DAY_RECEIVED_COUNT_EXCEED              FailReasonType = "DAY_RECEIVED_COUNT_EXCEED"
	FAILREASONTYPE_PRODUCT_AUTH_CHECK_FAIL                FailReasonType = "PRODUCT_AUTH_CHECK_FAIL"
	FAILREASONTYPE_OVERDUE_CLOSE                          FailReasonType = "OVERDUE_CLOSE"
	FAILREASONTYPE_ID_CARD_NOT_CORRECT                    FailReasonType = "ID_CARD_NOT_CORRECT"
	FAILREASONTYPE_ACCOUNT_NOT_EXIST                      FailReasonType = "ACCOUNT_NOT_EXIST"
	FAILREASONTYPE_TRANSFER_RISK                          FailReasonType = "TRANSFER_RISK"
	FAILREASONTYPE_PAYROLL_CARD_ALREADY_LOGOUT            FailReasonType = "PAYROLL_CARD_ALREADY_LOGOUT"
	FAILREASONTYPE_PAYROLL_CARD_ALREADY_FROZEN            FailReasonType = "PAYROLL_CARD_ALREADY_FROZEN"
	FAILREASONTYPE_PAYROLL_CARD_UNAUTHORIZED              FailReasonType = "PAYROLL_CARD_UNAUTHORIZED"
	FAILREASONTYPE_PAYROLL_CARD_USER_NOT_OPEN             FailReasonType = "PAYROLL_CARD_USER_NOT_OPEN"
	FAILREASONTYPE_PAYROLL_CARD_NAME_CARD_NOT_MATCH       FailReasonType = "PAYROLL_CARD_NAME_CARD_NOT_MATCH"
	FAILREASONTYPE_PAYROLL_CARD_ID_CARD_NOT_MATCH         FailReasonType = "PAYROLL_CARD_ID_CARD_NOT_MATCH"
	FAILREASONTYPE_PAYROLL_CARD_BANKCARD_UNBUNDLING       FailReasonType = "PAYROLL_CARD_BANKCARD_UNBUNDLING"
	FAILREASONTYPE_BANK_CARD_COLLECTIONS_ABOVE_QUOTA      FailReasonType = "BANK_CARD_COLLECTIONS_ABOVE_QUOTA"
	FAILREASONTYPE_BANK_CARD_ACCOUNT_ABNORMAL             FailReasonType = "BANK_CARD_ACCOUNT_ABNORMAL"
	FAILREASONTYPE_BANK_CARD_STATUS_ABNORMAL              FailReasonType = "BANK_CARD_STATUS_ABNORMAL"
	FAILREASONTYPE_BANK_CARD_BANK_INFO_WRONG              FailReasonType = "BANK_CARD_BANK_INFO_WRONG"
	FAILREASONTYPE_BANK_CARD_CARD_INFO_WRONG              FailReasonType = "BANK_CARD_CARD_INFO_WRONG"
	FAILREASONTYPE_OTHER_FAIL_REASON_TYPE                 FailReasonType = "OTHER_FAIL_REASON_TYPE"
	FAILREASONTYPE_REALNAME_ACCOUNT_RECEIVED_QUOTA_EXCEED FailReasonType = "REALNAME_ACCOUNT_RECEIVED_QUOTA_EXCEED"
	FAILREASONTYPE_RECEIVE_ACCOUNT_NOT_PERMMIT            FailReasonType = "RECEIVE_ACCOUNT_NOT_PERMMIT"
	FAILREASONTYPE_PAYEE_ACCOUNT_ABNORMAL                 FailReasonType = "PAYEE_ACCOUNT_ABNORMAL"
	FAILREASONTYPE_PAYER_ACCOUNT_ABNORMAL                 FailReasonType = "PAYER_ACCOUNT_ABNORMAL"
	FAILREASONTYPE_TRANSFER_REMARK_SET_FAIL               FailReasonType = "TRANSFER_REMARK_SET_FAIL"
)

// GetTransferBatchByNoRequest
type GetTransferBatchByNoRequest struct {
	// 微信支付批次单号，微信商家转账系统返回的唯一标识
	BatchId *string `json:"batch_id"`
	// true-是；false-否，默认否。商户可选择是否查询指定状态的转账明细单，当转账批次单状态为“FINISHED”（已完成）时，才会返回满足条件的转账明细单
	NeedQueryDetail *bool `json:"need_query_detail"`
	// 该次请求资源的起始位置。返回的明细是按照设置的明细条数进行分页展示的，一次查询可能无法返回所有明细，我们使用该参数标识查询开始位置，默认值为0
	Offset *int64 `json:"offset,omitempty"`
	// 该次请求可返回的最大明细条数，最小20条，最大100条，不传则默认20条。不足20条按实际条数返回
	Limit *int64 `json:"limit,omitempty"`
	// 查询指定状态的转账明细单   ALL:全部。需要同时查询转账成功和转账失败的明细单   SUCCESS:转账成功。只查询转账成功的明细单   FAIL:转账失败。只查询转账失败的明细单
	DetailStatus *string `json:"detail_status,omitempty"`
}

func (o GetTransferBatchByNoRequest) MarshalJSON() ([]byte, error) {
	toSerialize := map[string]interface{}{}

	if o.BatchId == nil {
		return nil, fmt.Errorf("field `BatchId` is required and must be specified in GetTransferBatchByNoRequest")
	}
	toSerialize["batch_id"] = o.BatchId

	if o.NeedQueryDetail == nil {
		return nil, fmt.Errorf("field `NeedQueryDetail` is required and must be specified in GetTransferBatchByNoRequest")
	}
	toSerialize["need_query_detail"] = o.NeedQueryDetail

	if o.Offset != nil {
		toSerialize["offset"] = o.Offset
	}

	if o.Limit != nil {
		toSerialize["limit"] = o.Limit
	}

	if o.DetailStatus != nil {
		toSerialize["detail_status"] = o.DetailStatus
	}
	return json.Marshal(toSerialize)
}

func (o GetTransferBatchByNoRequest) String() string {
	var ret string
	if o.BatchId == nil {
		ret += "BatchId:<nil>, "
	} else {
		ret += fmt.Sprintf("BatchId:%v, ", *o.BatchId)
	}

	if o.NeedQueryDetail == nil {
		ret += "NeedQueryDetail:<nil>, "
	} else {
		ret += fmt.Sprintf("NeedQueryDetail:%v, ", *o.NeedQueryDetail)
	}

	if o.Offset == nil {
		ret += "Offset:<nil>, "
	} else {
		ret += fmt.Sprintf("Offset:%v, ", *o.Offset)
	}

	if o.Limit == nil {
		ret += "Limit:<nil>, "
	} else {
		ret += fmt.Sprintf("Limit:%v, ", *o.Limit)
	}

	if o.DetailStatus == nil {
		ret += "DetailStatus:<nil>"
	} else {
		ret += fmt.Sprintf("DetailStatus:%v", *o.DetailStatus)
	}

	return fmt.Sprintf("GetTransferBatchByNoRequest{%s}", ret)
}

func (o GetTransferBatchByNoRequest) Clone() *GetTransferBatchByNoRequest {
	ret := GetTransferBatchByNoRequest{}

	if o.BatchId != nil {
		ret.BatchId = new(string)
		*ret.BatchId = *o.BatchId
	}

	if o.NeedQueryDetail != nil {
		ret.NeedQueryDetail = new(bool)
		*ret.NeedQueryDetail = *o.NeedQueryDetail
	}

	if o.Offset != nil {
		ret.Offset = new(int64)
		*ret.Offset = *o.Offset
	}

	if o.Limit != nil {
		ret.Limit = new(int64)
		*ret.Limit = *o.Limit
	}

	if o.DetailStatus != nil {
		ret.DetailStatus = new(string)
		*ret.DetailStatus = *o.DetailStatus
	}

	return &ret
}

// GetTransferBatchByOutNoRequest
type GetTransferBatchByOutNoRequest struct {
	// 商户系统内部的商家批次单号，在商户系统内部唯一
	OutBatchNo *string `json:"out_batch_no"`
	// true-是；false-否，默认否。商户可选择是否查询指定状态的转账明细单，当转账批次单状态为“FINISHED”（已完成）时，才会返回满足条件的转账明细单
	NeedQueryDetail *bool `json:"need_query_detail"`
	// 该次请求资源（转账明细单）的起始位置，从0开始，默认值为0
	Offset *int64 `json:"offset,omitempty"`
	// 该次请求可返回的最大资源（转账明细单）条数，最小20条，最大100条，不传则默认20条。不足20条按实际条数返回
	Limit *int64 `json:"limit,omitempty"`
	// 查询指定状态的转账明细单   ALL:全部。需要同时查询转账成功和转账失败的明细单   SUCCESS:转账成功。只查询转账成功的明细单   FAIL:转账失败。只查询转账失败的明细单
	DetailStatus *string `json:"detail_status,omitempty"`
}

func (o GetTransferBatchByOutNoRequest) MarshalJSON() ([]byte, error) {
	toSerialize := map[string]interface{}{}

	if o.OutBatchNo == nil {
		return nil, fmt.Errorf("field `OutBatchNo` is required and must be specified in GetTransferBatchByOutNoRequest")
	}
	toSerialize["out_batch_no"] = o.OutBatchNo

	if o.NeedQueryDetail == nil {
		return nil, fmt.Errorf("field `NeedQueryDetail` is required and must be specified in GetTransferBatchByOutNoRequest")
	}
	toSerialize["need_query_detail"] = o.NeedQueryDetail

	if o.Offset != nil {
		toSerialize["offset"] = o.Offset
	}

	if o.Limit != nil {
		toSerialize["limit"] = o.Limit
	}

	if o.DetailStatus != nil {
		toSerialize["detail_status"] = o.DetailStatus
	}
	return json.Marshal(toSerialize)
}

func (o GetTransferBatchByOutNoRequest) String() string {
	var ret string
	if o.OutBatchNo == nil {
		ret += "OutBatchNo:<nil>, "
	} else {
		ret += fmt.Sprintf("OutBatchNo:%v, ", *o.OutBatchNo)
	}

	if o.NeedQueryDetail == nil {
		ret += "NeedQueryDetail:<nil>, "
	} else {
		ret += fmt.Sprintf("NeedQueryDetail:%v, ", *o.NeedQueryDetail)
	}

	if o.Offset == nil {
		ret += "Offset:<nil>, "
	} else {
		ret += fmt.Sprintf("Offset:%v, ", *o.Offset)
	}

	if o.Limit == nil {
		ret += "Limit:<nil>, "
	} else {
		ret += fmt.Sprintf("Limit:%v, ", *o.Limit)
	}

	if o.DetailStatus == nil {
		ret += "DetailStatus:<nil>"
	} else {
		ret += fmt.Sprintf("DetailStatus:%v", *o.DetailStatus)
	}

	return fmt.Sprintf("GetTransferBatchByOutNoRequest{%s}", ret)
}

func (o GetTransferBatchByOutNoRequest) Clone() *GetTransferBatchByOutNoRequest {
	ret := GetTransferBatchByOutNoRequest{}

	if o.OutBatchNo != nil {
		ret.OutBatchNo = new(string)
		*ret.OutBatchNo = *o.OutBatchNo
	}

	if o.NeedQueryDetail != nil {
		ret.NeedQueryDetail = new(bool)
		*ret.NeedQueryDetail = *o.NeedQueryDetail
	}

	if o.Offset != nil {
		ret.Offset = new(int64)
		*ret.Offset = *o.Offset
	}

	if o.Limit != nil {
		ret.Limit = new(int64)
		*ret.Limit = *o.Limit
	}

	if o.DetailStatus != nil {
		ret.DetailStatus = new(string)
		*ret.DetailStatus = *o.DetailStatus
	}

	return &ret
}

// GetTransferDetailByNoRequest
type GetTransferDetailByNoRequest struct {
	// 微信支付批次单号，微信商家转账系统返回的唯一标识
	BatchId *string `json:"batch_id"`
	// 微信支付系统内部区分转账批次单下不同转账明细单的唯一标识
	DetailId *string `json:"detail_id"`
}

func (o GetTransferDetailByNoRequest) MarshalJSON() ([]byte, error) {
	toSerialize := map[string]interface{}{}

	if o.BatchId == nil {
		return nil, fmt.Errorf("field `BatchId` is required and must be specified in GetTransferDetailByNoRequest")
	}
	toSerialize["batch_id"] = o.BatchId

	if o.DetailId == nil {
		return nil, fmt.Errorf("field `DetailId` is required and must be specified in GetTransferDetailByNoRequest")
	}
	toSerialize["detail_id"] = o.DetailId
	return json.Marshal(toSerialize)
}

func (o GetTransferDetailByNoRequest) String() string {
	var ret string
	if o.BatchId == nil {
		ret += "BatchId:<nil>, "
	} else {
		ret += fmt.Sprintf("BatchId:%v, ", *o.BatchId)
	}

	if o.DetailId == nil {
		ret += "DetailId:<nil>"
	} else {
		ret += fmt.Sprintf("DetailId:%v", *o.DetailId)
	}

	return fmt.Sprintf("GetTransferDetailByNoRequest{%s}", ret)
}

func (o GetTransferDetailByNoRequest) Clone() *GetTransferDetailByNoRequest {
	ret := GetTransferDetailByNoRequest{}

	if o.BatchId != nil {
		ret.BatchId = new(string)
		*ret.BatchId = *o.BatchId
	}

	if o.DetailId != nil {
		ret.DetailId = new(string)
		*ret.DetailId = *o.DetailId
	}

	return &ret
}

// GetTransferDetailByOutNoRequest
type GetTransferDetailByOutNoRequest struct {
	// 商户系统内部的商家批次单号，在商户系统内部唯一
	OutBatchNo *string `json:"out_batch_no"`
	// 商户系统内部区分转账批次单下不同转账明细单的唯一标识
	OutDetailNo *string `json:"out_detail_no"`
}

func (o GetTransferDetailByOutNoRequest) MarshalJSON() ([]byte, error) {
	toSerialize := map[string]interface{}{}

	if o.OutBatchNo == nil {
		return nil, fmt.Errorf("field `OutBatchNo` is required and must be specified in GetTransferDetailByOutNoRequest")
	}
	toSerialize["out_batch_no"] = o.OutBatchNo

	if o.OutDetailNo == nil {
		return nil, fmt.Errorf("field `OutDetailNo` is required and must be specified in GetTransferDetailByOutNoRequest")
	}
	toSerialize["out_detail_no"] = o.OutDetailNo
	return json.Marshal(toSerialize)
}

func (o GetTransferDetailByOutNoRequest) String() string {
	var ret string
	if o.OutBatchNo == nil {
		ret += "OutBatchNo:<nil>, "
	} else {
		ret += fmt.Sprintf("OutBatchNo:%v, ", *o.OutBatchNo)
	}

	if o.OutDetailNo == nil {
		ret += "OutDetailNo:<nil>"
	} else {
		ret += fmt.Sprintf("OutDetailNo:%v", *o.OutDetailNo)
	}

	return fmt.Sprintf("GetTransferDetailByOutNoRequest{%s}", ret)
}

func (o GetTransferDetailByOutNoRequest) Clone() *GetTransferDetailByOutNoRequest {
	ret := GetTransferDetailByOutNoRequest{}

	if o.OutBatchNo != nil {
		ret.OutBatchNo = new(string)
		*ret.OutBatchNo = *o.OutBatchNo
	}

	if o.OutDetailNo != nil {
		ret.OutDetailNo = new(string)
		*ret.OutDetailNo = *o.OutDetailNo
	}

	return &ret
}

// InitiateTransferBatchRequest
type InitiateTransferBatchRequest struct {
	// 特约商户号
	SubMchid *string `json:"sub_mchid"`
	// 微信分配的特约商户公众账号ID，特约商户授权类型为INFORMATION_AUTHORIZATION_TYPE和INFORMATION_AND_FUND_AUTHORIZATION_TYPE时 需要填写
	SubAppid *string `json:"sub_appid,omitempty"`
	// 商户系统内部的商家批次单号，在商户系统内部唯一
	OutBatchNo *string `json:"out_batch_no"`
	// 该笔批量转账的名称
	BatchName *string `json:"batch_name"`
	// 转账说明，UTF8编码，最多允许32个字符
	BatchRemark *string `json:"batch_remark"`
	// 转账金额单位为“分”。转账总金额必须与批次内所有明细转账金额之和保持一致，否则无法发起转账操作
	TotalAmount *int64 `json:"total_amount"`
	// 一个转账批次单最多发起三千笔转账。转账总笔数必须与批次内所有明细之和保持一致，否则无法发起转账操作
	TotalNum *int64 `json:"total_num"`
	// 发起批量转账的明细列表，最多三千笔
	TransferDetailList []TransferDetailInput `json:"transfer_detail_list,omitempty"`
	// 微信分配的服务商商户公众账号ID，特约商户授权类型为FUND_AUTHORIZATION_TYPE时 需要填写
	SpAppid *string `json:"sp_appid,omitempty"`
	// 特约商户授权类型
	AuthorizationType *AuthType `json:"authorization_type"`
	// 批量转账用途
	TransferPurpose *TransferUseType `json:"transfer_purpose,omitempty"`
	// 商户的转账场景
	TransferScene *TransferScene `json:"transfer_scene,omitempty"`
}

func (o InitiateTransferBatchRequest) MarshalJSON() ([]byte, error) {
	toSerialize := map[string]interface{}{}

	if o.SubMchid == nil {
		return nil, fmt.Errorf("field `SubMchid` is required and must be specified in InitiateTransferBatchRequest")
	}
	toSerialize["sub_mchid"] = o.SubMchid

	if o.SubAppid != nil {
		toSerialize["sub_appid"] = o.SubAppid
	}

	if o.OutBatchNo == nil {
		return nil, fmt.Errorf("field `OutBatchNo` is required and must be specified in InitiateTransferBatchRequest")
	}
	toSerialize["out_batch_no"] = o.OutBatchNo

	if o.BatchName == nil {
		return nil, fmt.Errorf("field `BatchName` is required and must be specified in InitiateTransferBatchRequest")
	}
	toSerialize["batch_name"] = o.BatchName

	if o.BatchRemark == nil {
		return nil, fmt.Errorf("field `BatchRemark` is required and must be specified in InitiateTransferBatchRequest")
	}
	toSerialize["batch_remark"] = o.BatchRemark

	if o.TotalAmount == nil {
		return nil, fmt.Errorf("field `TotalAmount` is required and must be specified in InitiateTransferBatchRequest")
	}
	toSerialize["total_amount"] = o.TotalAmount

	if o.TotalNum == nil {
		return nil, fmt.Errorf("field `TotalNum` is required and must be specified in InitiateTransferBatchRequest")
	}
	toSerialize["total_num"] = o.TotalNum

	if o.TransferDetailList != nil {
		toSerialize["transfer_detail_list"] = o.TransferDetailList
	}

	if o.SpAppid != nil {
		toSerialize["sp_appid"] = o.SpAppid
	}

	if o.AuthorizationType == nil {
		return nil, fmt.Errorf("field `AuthorizationType` is required and must be specified in InitiateTransferBatchRequest")
	}
	toSerialize["authorization_type"] = o.AuthorizationType

	if o.TransferPurpose != nil {
		toSerialize["transfer_purpose"] = o.TransferPurpose
	}

	if o.TransferScene != nil {
		toSerialize["transfer_scene"] = o.TransferScene
	}
	return json.Marshal(toSerialize)
}

func (o InitiateTransferBatchRequest) String() string {
	var ret string
	if o.SubMchid == nil {
		ret += "SubMchid:<nil>, "
	} else {
		ret += fmt.Sprintf("SubMchid:%v, ", *o.SubMchid)
	}

	if o.SubAppid == nil {
		ret += "SubAppid:<nil>, "
	} else {
		ret += fmt.Sprintf("SubAppid:%v, ", *o.SubAppid)
	}

	if o.OutBatchNo == nil {
		ret += "OutBatchNo:<nil>, "
	} else {
		ret += fmt.Sprintf("OutBatchNo:%v, ", *o.OutBatchNo)
	}

	if o.BatchName == nil {
		ret += "BatchName:<nil>, "
	} else {
		ret += fmt.Sprintf("BatchName:%v, ", *o.BatchName)
	}

	if o.BatchRemark == nil {
		ret += "BatchRemark:<nil>, "
	} else {
		ret += fmt.Sprintf("BatchRemark:%v, ", *o.BatchRemark)
	}

	if o.TotalAmount == nil {
		ret += "TotalAmount:<nil>, "
	} else {
		ret += fmt.Sprintf("TotalAmount:%v, ", *o.TotalAmount)
	}

	if o.TotalNum == nil {
		ret += "TotalNum:<nil>, "
	} else {
		ret += fmt.Sprintf("TotalNum:%v, ", *o.TotalNum)
	}

	ret += fmt.Sprintf("TransferDetailList:%v, ", o.TransferDetailList)

	if o.SpAppid == nil {
		ret += "SpAppid:<nil>, "
	} else {
		ret += fmt.Sprintf("SpAppid:%v, ", *o.SpAppid)
	}

	if o.AuthorizationType == nil {
		ret += "AuthorizationType:<nil>, "
	} else {
		ret += fmt.Sprintf("AuthorizationType:%v, ", *o.AuthorizationType)
	}

	if o.TransferPurpose == nil {
		ret += "TransferPurpose:<nil>, "
	} else {
		ret += fmt.Sprintf("TransferPurpose:%v, ", *o.TransferPurpose)
	}

	if o.TransferScene == nil {
		ret += "TransferScene:<nil>"
	} else {
		ret += fmt.Sprintf("TransferScene:%v", *o.TransferScene)
	}

	return fmt.Sprintf("InitiateTransferBatchRequest{%s}", ret)
}

func (o InitiateTransferBatchRequest) Clone() *InitiateTransferBatchRequest {
	ret := InitiateTransferBatchRequest{}

	if o.SubMchid != nil {
		ret.SubMchid = new(string)
		*ret.SubMchid = *o.SubMchid
	}

	if o.SubAppid != nil {
		ret.SubAppid = new(string)
		*ret.SubAppid = *o.SubAppid
	}

	if o.OutBatchNo != nil {
		ret.OutBatchNo = new(string)
		*ret.OutBatchNo = *o.OutBatchNo
	}

	if o.BatchName != nil {
		ret.BatchName = new(string)
		*ret.BatchName = *o.BatchName
	}

	if o.BatchRemark != nil {
		ret.BatchRemark = new(string)
		*ret.BatchRemark = *o.BatchRemark
	}

	if o.TotalAmount != nil {
		ret.TotalAmount = new(int64)
		*ret.TotalAmount = *o.TotalAmount
	}

	if o.TotalNum != nil {
		ret.TotalNum = new(int64)
		*ret.TotalNum = *o.TotalNum
	}

	if o.TransferDetailList != nil {
		ret.TransferDetailList = make([]TransferDetailInput, len(o.TransferDetailList))
		for i, item := range o.TransferDetailList {
			ret.TransferDetailList[i] = *item.Clone()
		}
	}

	if o.SpAppid != nil {
		ret.SpAppid = new(string)
		*ret.SpAppid = *o.SpAppid
	}

	if o.AuthorizationType != nil {
		ret.AuthorizationType = new(AuthType)
		*ret.AuthorizationType = *o.AuthorizationType
	}

	if o.TransferPurpose != nil {
		ret.TransferPurpose = new(TransferUseType)
		*ret.TransferPurpose = *o.TransferPurpose
	}

	if o.TransferScene != nil {
		ret.TransferScene = new(TransferScene)
		*ret.TransferScene = *o.TransferScene
	}

	return &ret
}

// InitiateTransferBatchResponse
type InitiateTransferBatchResponse struct {
	// 商户系统内部的商家批次单号，在商户系统内部唯一
	OutBatchNo *string `json:"out_batch_no"`
	// 微信支付批次单号，微信商家转账系统返回的唯一标识
	BatchId *string `json:"batch_id"`
	// 批次受理成功时返回，按照使用rfc3339所定义的格式，格式为YYYY-MM-DDThh:mm:ss+TIMEZONE
	CreateTime *time.Time `json:"create_time"`
}

func (o InitiateTransferBatchResponse) MarshalJSON() ([]byte, error) {
	toSerialize := map[string]interface{}{}

	if o.OutBatchNo == nil {
		return nil, fmt.Errorf("field `OutBatchNo` is required and must be specified in InitiateTransferBatchResponse")
	}
	toSerialize["out_batch_no"] = o.OutBatchNo

	if o.BatchId == nil {
		return nil, fmt.Errorf("field `BatchId` is required and must be specified in InitiateTransferBatchResponse")
	}
	toSerialize["batch_id"] = o.BatchId

	if o.CreateTime == nil {
		return nil, fmt.Errorf("field `CreateTime` is required and must be specified in InitiateTransferBatchResponse")
	}
	toSerialize["create_time"] = o.CreateTime.Format(time.RFC3339)
	return json.Marshal(toSerialize)
}

func (o InitiateTransferBatchResponse) String() string {
	var ret string
	if o.OutBatchNo == nil {
		ret += "OutBatchNo:<nil>, "
	} else {
		ret += fmt.Sprintf("OutBatchNo:%v, ", *o.OutBatchNo)
	}

	if o.BatchId == nil {
		ret += "BatchId:<nil>, "
	} else {
		ret += fmt.Sprintf("BatchId:%v, ", *o.BatchId)
	}

	if o.CreateTime == nil {
		ret += "CreateTime:<nil>"
	} else {
		ret += fmt.Sprintf("CreateTime:%v", *o.CreateTime)
	}

	return fmt.Sprintf("InitiateTransferBatchResponse{%s}", ret)
}

func (o InitiateTransferBatchResponse) Clone() *InitiateTransferBatchResponse {
	ret := InitiateTransferBatchResponse{}

	if o.OutBatchNo != nil {
		ret.OutBatchNo = new(string)
		*ret.OutBatchNo = *o.OutBatchNo
	}

	if o.BatchId != nil {
		ret.BatchId = new(string)
		*ret.BatchId = *o.BatchId
	}

	if o.CreateTime != nil {
		ret.CreateTime = new(time.Time)
		*ret.CreateTime = *o.CreateTime
	}

	return &ret
}

// PayeeAccountType   WECHATPAY_ACCOUNT - 微信零钱，微信支付零钱账户  BANK_ACCOUNT - 银行卡，银行卡账户
type PayeeAccountType string

func (e PayeeAccountType) Ptr() *PayeeAccountType {
	return &e
}

// Enums of PayeeAccountType
const (
	PAYEEACCOUNTTYPE_WECHATPAY_ACCOUNT PayeeAccountType = "WECHATPAY_ACCOUNT"
	PAYEEACCOUNTTYPE_BANK_ACCOUNT      PayeeAccountType = "BANK_ACCOUNT"
)

// TransferBatchEntity
type TransferBatchEntity struct {
	// 微信支付分配的服务商商户号
	SpMchid *string `json:"sp_mchid"`
	// 微信支付分配的特约商户号
	SubMchid *string `json:"sub_mchid"`
	// 商户系统内部的商家批次单号，在商户系统内部唯一
	OutBatchNo *string `json:"out_batch_no"`
	// 微信支付批次单号，微信商家转账系统返回的唯一标识
	BatchId *string `json:"batch_id"`
	// 微信分配的特约商户公众账号ID。特约商户appid
	SubAppid *string `json:"sub_appid,omitempty"`
	// WAIT_PAY：待付款，商户员工确认付款阶段。ACCEPTED:已受理。批次已受理成功，若发起批量转账的30分钟后，转账批次单仍处于该状态，可能原因是商户账户余额不足等。商户可查询账户资金流水，若该笔转账批次单的扣款已经发生，则表示批次已经进入转账中，请再次查单确认  PROCESSING:转账中。已开始处理批次内的转账明细单  FINISHED:已完成。批次内的所有转账明细单都已处理完成  CLOSED:已关闭。可查询具体的批次关闭原因确认
	BatchStatus *string `json:"batch_status"`
	// API:API方式发起   WEB:页面方式发起
	BatchType *string `json:"batch_type"`
	// 该笔批量转账的名称
	BatchName *string `json:"batch_name"`
	// 转账说明，UTF8编码，最多允许32个字符
	BatchRemark *string `json:"batch_remark"`
	// 转账金额单位为“分”
	TotalAmount *int64 `json:"total_amount"`
	// 一个转账批次单最多发起三千笔转账
	TotalNum *int64 `json:"total_num"`
	// 批次受理成功时返回，按照使用rfc3339所定义的格式，格式为YYYY-MM-DDThh:mm:ss+TIMEZONE
	CreateTime *time.Time `json:"create_time,omitempty"`
	// 批次最近一次状态变更的时间，按照使用rfc3339所定义的格式，格式为YYYY-MM-DDThh:mm:ss+TIMEZONE
	UpdateTime *time.Time `json:"update_time,omitempty"`
	// 转账成功的金额，单位为“分”。当批次状态为“PROCESSING”（转账中）时，转账成功金额随时可能变化
	SuccessAmount *int64 `json:"success_amount,omitempty"`
	// 转账成功的笔数。当批次状态为“PROCESSING”（转账中）时，转账成功笔数随时可能变化
	SuccessNum *int64 `json:"success_num,omitempty"`
	// 转账失败的金额，单位为“分”
	FailAmount *int64 `json:"fail_amount,omitempty"`
	// 转账失败的笔数
	FailNum *int64 `json:"fail_num,omitempty"`
	// 当批次状态为“FINISHED”（已完成），且成功查询到转账明细单时返回。包括微信明细单号、明细状态信息
	TransferDetailList []TransferDetailCompact `json:"transfer_detail_list,omitempty"`
	// 微信分配的服务商商户公众账号ID，特约商户授权类型为FUND_AUTHORIZATION_TYPE时才有该字段
	SpAppid *string `json:"sp_appid,omitempty"`
	// 特约商户授权类型
	AuthorizationType *AuthType `json:"authorization_type"`
	// 如果批次单状态为“CLOSED”（已关闭），则有关闭原因
	CloseReason *CloseReasonType `json:"close_reason,omitempty"`
	// 批量转账用途
	TransferPurpose *TransferUseType `json:"transfer_purpose,omitempty"`
	// 商户的转账场景
	TransferScene *TransferScene `json:"transfer_scene,omitempty"`
}

func (o TransferBatchEntity) MarshalJSON() ([]byte, error) {
	toSerialize := map[string]interface{}{}

	if o.SpMchid == nil {
		return nil, fmt.Errorf("field `SpMchid` is required and must be specified in TransferBatchEntity")
	}
	toSerialize["sp_mchid"] = o.SpMchid

	if o.SubMchid == nil {
		return nil, fmt.Errorf("field `SubMchid` is required and must be specified in TransferBatchEntity")
	}
	toSerialize["sub_mchid"] = o.SubMchid

	if o.OutBatchNo == nil {
		return nil, fmt.Errorf("field `OutBatchNo` is required and must be specified in TransferBatchEntity")
	}
	toSerialize["out_batch_no"] = o.OutBatchNo

	if o.BatchId == nil {
		return nil, fmt.Errorf("field `BatchId` is required and must be specified in TransferBatchEntity")
	}
	toSerialize["batch_id"] = o.BatchId

	if o.SubAppid != nil {
		toSerialize["sub_appid"] = o.SubAppid
	}

	if o.BatchStatus == nil {
		return nil, fmt.Errorf("field `BatchStatus` is required and must be specified in TransferBatchEntity")
	}
	toSerialize["batch_status"] = o.BatchStatus

	if o.BatchType == nil {
		return nil, fmt.Errorf("field `BatchType` is required and must be specified in TransferBatchEntity")
	}
	toSerialize["batch_type"] = o.BatchType

	if o.BatchName == nil {
		return nil, fmt.Errorf("field `BatchName` is required and must be specified in TransferBatchEntity")
	}
	toSerialize["batch_name"] = o.BatchName

	if o.BatchRemark == nil {
		return nil, fmt.Errorf("field `BatchRemark` is required and must be specified in TransferBatchEntity")
	}
	toSerialize["batch_remark"] = o.BatchRemark

	if o.TotalAmount == nil {
		return nil, fmt.Errorf("field `TotalAmount` is required and must be specified in TransferBatchEntity")
	}
	toSerialize["total_amount"] = o.TotalAmount

	if o.TotalNum == nil {
		return nil, fmt.Errorf("field `TotalNum` is required and must be specified in TransferBatchEntity")
	}
	toSerialize["total_num"] = o.TotalNum

	if o.CreateTime != nil {
		toSerialize["create_time"] = o.CreateTime.Format(time.RFC3339)
	}

	if o.UpdateTime != nil {
		toSerialize["update_time"] = o.UpdateTime.Format(time.RFC3339)
	}

	if o.SuccessAmount != nil {
		toSerialize["success_amount"] = o.SuccessAmount
	}

	if o.SuccessNum != nil {
		toSerialize["success_num"] = o.SuccessNum
	}

	if o.FailAmount != nil {
		toSerialize["fail_amount"] = o.FailAmount
	}

	if o.FailNum != nil {
		toSerialize["fail_num"] = o.FailNum
	}

	if o.TransferDetailList != nil {
		toSerialize["transfer_detail_list"] = o.TransferDetailList
	}

	if o.SpAppid != nil {
		toSerialize["sp_appid"] = o.SpAppid
	}

	if o.AuthorizationType == nil {
		return nil, fmt.Errorf("field `AuthorizationType` is required and must be specified in TransferBatchEntity")
	}
	toSerialize["authorization_type"] = o.AuthorizationType

	if o.CloseReason != nil {
		toSerialize["close_reason"] = o.CloseReason
	}

	if o.TransferPurpose != nil {
		toSerialize["transfer_purpose"] = o.TransferPurpose
	}

	if o.TransferScene != nil {
		toSerialize["transfer_scene"] = o.TransferScene
	}
	return json.Marshal(toSerialize)
}

func (o TransferBatchEntity) String() string {
	var ret string
	if o.SpMchid == nil {
		ret += "SpMchid:<nil>, "
	} else {
		ret += fmt.Sprintf("SpMchid:%v, ", *o.SpMchid)
	}

	if o.SubMchid == nil {
		ret += "SubMchid:<nil>, "
	} else {
		ret += fmt.Sprintf("SubMchid:%v, ", *o.SubMchid)
	}

	if o.OutBatchNo == nil {
		ret += "OutBatchNo:<nil>, "
	} else {
		ret += fmt.Sprintf("OutBatchNo:%v, ", *o.OutBatchNo)
	}

	if o.BatchId == nil {
		ret += "BatchId:<nil>, "
	} else {
		ret += fmt.Sprintf("BatchId:%v, ", *o.BatchId)
	}

	if o.SubAppid == nil {
		ret += "SubAppid:<nil>, "
	} else {
		ret += fmt.Sprintf("SubAppid:%v, ", *o.SubAppid)
	}

	if o.BatchStatus == nil {
		ret += "BatchStatus:<nil>, "
	} else {
		ret += fmt.Sprintf("BatchStatus:%v, ", *o.BatchStatus)
	}

	if o.BatchType == nil {
		ret += "BatchType:<nil>, "
	} else {
		ret += fmt.Sprintf("BatchType:%v, ", *o.BatchType)
	}

	if o.BatchName == nil {
		ret += "BatchName:<nil>, "
	} else {
		ret += fmt.Sprintf("BatchName:%v, ", *o.BatchName)
	}

	if o.BatchRemark == nil {
		ret += "BatchRemark:<nil>, "
	} else {
		ret += fmt.Sprintf("BatchRemark:%v, ", *o.BatchRemark)
	}

	if o.TotalAmount == nil {
		ret += "TotalAmount:<nil>, "
	} else {
		ret += fmt.Sprintf("TotalAmount:%v, ", *o.TotalAmount)
	}

	if o.TotalNum == nil {
		ret += "TotalNum:<nil>, "
	} else {
		ret += fmt.Sprintf("TotalNum:%v, ", *o.TotalNum)
	}

	if o.CreateTime == nil {
		ret += "CreateTime:<nil>, "
	} else {
		ret += fmt.Sprintf("CreateTime:%v, ", *o.CreateTime)
	}

	if o.UpdateTime == nil {
		ret += "UpdateTime:<nil>, "
	} else {
		ret += fmt.Sprintf("UpdateTime:%v, ", *o.UpdateTime)
	}

	if o.SuccessAmount == nil {
		ret += "SuccessAmount:<nil>, "
	} else {
		ret += fmt.Sprintf("SuccessAmount:%v, ", *o.SuccessAmount)
	}

	if o.SuccessNum == nil {
		ret += "SuccessNum:<nil>, "
	} else {
		ret += fmt.Sprintf("SuccessNum:%v, ", *o.SuccessNum)
	}

	if o.FailAmount == nil {
		ret += "FailAmount:<nil>, "
	} else {
		ret += fmt.Sprintf("FailAmount:%v, ", *o.FailAmount)
	}

	if o.FailNum == nil {
		ret += "FailNum:<nil>, "
	} else {
		ret += fmt.Sprintf("FailNum:%v, ", *o.FailNum)
	}

	ret += fmt.Sprintf("TransferDetailList:%v, ", o.TransferDetailList)

	if o.SpAppid == nil {
		ret += "SpAppid:<nil>, "
	} else {
		ret += fmt.Sprintf("SpAppid:%v, ", *o.SpAppid)
	}

	if o.AuthorizationType == nil {
		ret += "AuthorizationType:<nil>, "
	} else {
		ret += fmt.Sprintf("AuthorizationType:%v, ", *o.AuthorizationType)
	}

	if o.CloseReason == nil {
		ret += "CloseReason:<nil>, "
	} else {
		ret += fmt.Sprintf("CloseReason:%v, ", *o.CloseReason)
	}

	if o.TransferPurpose == nil {
		ret += "TransferPurpose:<nil>, "
	} else {
		ret += fmt.Sprintf("TransferPurpose:%v, ", *o.TransferPurpose)
	}

	if o.TransferScene == nil {
		ret += "TransferScene:<nil>"
	} else {
		ret += fmt.Sprintf("TransferScene:%v", *o.TransferScene)
	}

	return fmt.Sprintf("TransferBatchEntity{%s}", ret)
}

func (o TransferBatchEntity) Clone() *TransferBatchEntity {
	ret := TransferBatchEntity{}

	if o.SpMchid != nil {
		ret.SpMchid = new(string)
		*ret.SpMchid = *o.SpMchid
	}

	if o.SubMchid != nil {
		ret.SubMchid = new(string)
		*ret.SubMchid = *o.SubMchid
	}

	if o.OutBatchNo != nil {
		ret.OutBatchNo = new(string)
		*ret.OutBatchNo = *o.OutBatchNo
	}

	if o.BatchId != nil {
		ret.BatchId = new(string)
		*ret.BatchId = *o.BatchId
	}

	if o.SubAppid != nil {
		ret.SubAppid = new(string)
		*ret.SubAppid = *o.SubAppid
	}

	if o.BatchStatus != nil {
		ret.BatchStatus = new(string)
		*ret.BatchStatus = *o.BatchStatus
	}

	if o.BatchType != nil {
		ret.BatchType = new(string)
		*ret.BatchType = *o.BatchType
	}

	if o.BatchName != nil {
		ret.BatchName = new(string)
		*ret.BatchName = *o.BatchName
	}

	if o.BatchRemark != nil {
		ret.BatchRemark = new(string)
		*ret.BatchRemark = *o.BatchRemark
	}

	if o.TotalAmount != nil {
		ret.TotalAmount = new(int64)
		*ret.TotalAmount = *o.TotalAmount
	}

	if o.TotalNum != nil {
		ret.TotalNum = new(int64)
		*ret.TotalNum = *o.TotalNum
	}

	if o.CreateTime != nil {
		ret.CreateTime = new(time.Time)
		*ret.CreateTime = *o.CreateTime
	}

	if o.UpdateTime != nil {
		ret.UpdateTime = new(time.Time)
		*ret.UpdateTime = *o.UpdateTime
	}

	if o.SuccessAmount != nil {
		ret.SuccessAmount = new(int64)
		*ret.SuccessAmount = *o.SuccessAmount
	}

	if o.SuccessNum != nil {
		ret.SuccessNum = new(int64)
		*ret.SuccessNum = *o.SuccessNum
	}

	if o.FailAmount != nil {
		ret.FailAmount = new(int64)
		*ret.FailAmount = *o.FailAmount
	}

	if o.FailNum != nil {
		ret.FailNum = new(int64)
		*ret.FailNum = *o.FailNum
	}

	if o.TransferDetailList != nil {
		ret.TransferDetailList = make([]TransferDetailCompact, len(o.TransferDetailList))
		for i, item := range o.TransferDetailList {
			ret.TransferDetailList[i] = *item.Clone()
		}
	}

	if o.SpAppid != nil {
		ret.SpAppid = new(string)
		*ret.SpAppid = *o.SpAppid
	}

	if o.AuthorizationType != nil {
		ret.AuthorizationType = new(AuthType)
		*ret.AuthorizationType = *o.AuthorizationType
	}

	if o.CloseReason != nil {
		ret.CloseReason = new(CloseReasonType)
		*ret.CloseReason = *o.CloseReason
	}

	if o.TransferPurpose != nil {
		ret.TransferPurpose = new(TransferUseType)
		*ret.TransferPurpose = *o.TransferPurpose
	}

	if o.TransferScene != nil {
		ret.TransferScene = new(TransferScene)
		*ret.TransferScene = *o.TransferScene
	}

	return &ret
}

// TransferDetailCompact
type TransferDetailCompact struct {
	// 微信支付系统内部区分转账批次单下不同转账明细单的唯一标识
	DetailId *string `json:"detail_id"`
	// 商户系统内部区分转账批次单下不同转账明细单的唯一标识
	OutDetailNo *string `json:"out_detail_no"`
	// PROCESSING:转账中。正在处理中，转账结果尚未明确   SUCCESS:转账成功   FAIL:转账失败。需要确认失败原因后，再决定是否重新发起对该笔明细单的转账（并非整个转账批次单） REFUND: 退票
	DetailStatus *string `json:"detail_status"`
}

func (o TransferDetailCompact) MarshalJSON() ([]byte, error) {
	toSerialize := map[string]interface{}{}

	if o.DetailId == nil {
		return nil, fmt.Errorf("field `DetailId` is required and must be specified in TransferDetailCompact")
	}
	toSerialize["detail_id"] = o.DetailId

	if o.OutDetailNo == nil {
		return nil, fmt.Errorf("field `OutDetailNo` is required and must be specified in TransferDetailCompact")
	}
	toSerialize["out_detail_no"] = o.OutDetailNo

	if o.DetailStatus == nil {
		return nil, fmt.Errorf("field `DetailStatus` is required and must be specified in TransferDetailCompact")
	}
	toSerialize["detail_status"] = o.DetailStatus
	return json.Marshal(toSerialize)
}

func (o TransferDetailCompact) String() string {
	var ret string
	if o.DetailId == nil {
		ret += "DetailId:<nil>, "
	} else {
		ret += fmt.Sprintf("DetailId:%v, ", *o.DetailId)
	}

	if o.OutDetailNo == nil {
		ret += "OutDetailNo:<nil>, "
	} else {
		ret += fmt.Sprintf("OutDetailNo:%v, ", *o.OutDetailNo)
	}

	if o.DetailStatus == nil {
		ret += "DetailStatus:<nil>"
	} else {
		ret += fmt.Sprintf("DetailStatus:%v", *o.DetailStatus)
	}

	return fmt.Sprintf("TransferDetailCompact{%s}", ret)
}

func (o TransferDetailCompact) Clone() *TransferDetailCompact {
	ret := TransferDetailCompact{}

	if o.DetailId != nil {
		ret.DetailId = new(string)
		*ret.DetailId = *o.DetailId
	}

	if o.OutDetailNo != nil {
		ret.OutDetailNo = new(string)
		*ret.OutDetailNo = *o.OutDetailNo
	}

	if o.DetailStatus != nil {
		ret.DetailStatus = new(string)
		*ret.DetailStatus = *o.DetailStatus
	}

	return &ret
}

// TransferDetailEntity
type TransferDetailEntity struct {
	// 微信支付分配的商户号，此处为服务商商户号
	SpMchid *string `json:"sp_mchid"`
	// 商户系统内部的商家批次单号，在商户系统内部唯一
	OutBatchNo *string `json:"out_batch_no"`
	// 微信支付批次单号，微信商家转账系统返回的唯一标识
	BatchId *string `json:"batch_id"`
	// 微信分配的商户公众账号ID。特约商户授权类型为INFORMATION_AUTHORIZATION_TYPE和INFORMATION_AND_FUND_AUTHORIZATION_TYPE时对应的是特约商户的appid，特约商户授权类型为FUND_AUTHORIZATION_TYPE时为服务商的appid
	Appid *string `json:"appid,omitempty"`
	// 商户系统内部区分转账批次单下不同转账明细单的唯一标识
	OutDetailNo *string `json:"out_detail_no"`
	// 微信支付系统内部区分转账批次单下不同转账明细单的唯一标识
	DetailId *string `json:"detail_id"`
	// PROCESSING:转账中。正在处理中，转账结果尚未明确   SUCCESS:转账成功   FAIL:转账失败。需要确认失败原因后，再决定是否重新发起对该笔明细单的转账（并非整个转账批次单） REFUND: 退票
	DetailStatus *string `json:"detail_status"`
	// 转账金额单位为“分”
	TransferAmount *int64 `json:"transfer_amount"`
	// 单条转账备注（微信用户会收到该备注），UTF8编码，最多允许32个字符
	TransferRemark *string `json:"transfer_remark"`
	// 收款用户openid。如果转账特约商户授权类型是INFORMATION_AUTHORIZATION_TYPE，对应的是特约商户公众号下的openid;如果转账特约商户授权类型是FUND_AUTHORIZATION_TYPE，对应的是服务商商户公众号下的openid。
	Openid *string `json:"openid"`
	// 收款方姓名。采用标准RSA算法，公钥由微信侧提供 商户转账时传入了收款用户姓名、查询时会返回收款用户姓名
	Username *string `json:"username,omitempty" encryption:"EM_APIV3"`
	// 转账发起的时间，按照使用rfc3339所定义的格式，格式为YYYY-MM-DDThh:mm:ss+TIMEZONE
	InitiateTime *time.Time `json:"initiate_time"`
	// 明细最后一次状态变更的时间，按照使用rfc3339所定义的格式，格式为YYYY-MM-DDThh:mm:ss+TIMEZONE
	UpdateTime *time.Time `json:"update_time"`
	// 转账到银行卡时输出该字段
	BankName *string `json:"bank_name,omitempty"`
	// 转账到银行卡时输出该字段
	BankCardNumberTail *string `json:"bank_card_number_tail,omitempty"`
	// WXPAY_ACCOUNT 表示微信零钱，BANK_ACCOUNT表示银行卡账户
	AccountType *PayeeAccountType `json:"account_type,omitempty"`
	// 如果转账失败则有失败原因
	FailReason *FailReasonType `json:"fail_reason,omitempty"`
}

func (o TransferDetailEntity) MarshalJSON() ([]byte, error) {
	toSerialize := map[string]interface{}{}

	if o.SpMchid == nil {
		return nil, fmt.Errorf("field `SpMchid` is required and must be specified in TransferDetailEntity")
	}
	toSerialize["sp_mchid"] = o.SpMchid

	if o.OutBatchNo == nil {
		return nil, fmt.Errorf("field `OutBatchNo` is required and must be specified in TransferDetailEntity")
	}
	toSerialize["out_batch_no"] = o.OutBatchNo

	if o.BatchId == nil {
		return nil, fmt.Errorf("field `BatchId` is required and must be specified in TransferDetailEntity")
	}
	toSerialize["batch_id"] = o.BatchId

	if o.Appid != nil {
		toSerialize["appid"] = o.Appid
	}

	if o.OutDetailNo == nil {
		return nil, fmt.Errorf("field `OutDetailNo` is required and must be specified in TransferDetailEntity")
	}
	toSerialize["out_detail_no"] = o.OutDetailNo

	if o.DetailId == nil {
		return nil, fmt.Errorf("field `DetailId` is required and must be specified in TransferDetailEntity")
	}
	toSerialize["detail_id"] = o.DetailId

	if o.DetailStatus == nil {
		return nil, fmt.Errorf("field `DetailStatus` is required and must be specified in TransferDetailEntity")
	}
	toSerialize["detail_status"] = o.DetailStatus

	if o.TransferAmount == nil {
		return nil, fmt.Errorf("field `TransferAmount` is required and must be specified in TransferDetailEntity")
	}
	toSerialize["transfer_amount"] = o.TransferAmount

	if o.TransferRemark == nil {
		return nil, fmt.Errorf("field `TransferRemark` is required and must be specified in TransferDetailEntity")
	}
	toSerialize["transfer_remark"] = o.TransferRemark

	if o.Openid == nil {
		return nil, fmt.Errorf("field `Openid` is required and must be specified in TransferDetailEntity")
	}
	toSerialize["openid"] = o.Openid

	if o.Username != nil {
		toSerialize["username"] = o.Username
	}

	if o.InitiateTime == nil {
		return nil, fmt.Errorf("field `InitiateTime` is required and must be specified in TransferDetailEntity")
	}
	toSerialize["initiate_time"] = o.InitiateTime.Format(time.RFC3339)

	if o.UpdateTime == nil {
		return nil, fmt.Errorf("field `UpdateTime` is required and must be specified in TransferDetailEntity")
	}
	toSerialize["update_time"] = o.UpdateTime.Format(time.RFC3339)

	if o.BankName != nil {
		toSerialize["bank_name"] = o.BankName
	}

	if o.BankCardNumberTail != nil {
		toSerialize["bank_card_number_tail"] = o.BankCardNumberTail
	}

	if o.AccountType != nil {
		toSerialize["account_type"] = o.AccountType
	}

	if o.FailReason != nil {
		toSerialize["fail_reason"] = o.FailReason
	}
	return json.Marshal(toSerialize)
}

func (o TransferDetailEntity) String() string {
	var ret string
	if o.SpMchid == nil {
		ret += "SpMchid:<nil>, "
	} else {
		ret += fmt.Sprintf("SpMchid:%v, ", *o.SpMchid)
	}

	if o.OutBatchNo == nil {
		ret += "OutBatchNo:<nil>, "
	} else {
		ret += fmt.Sprintf("OutBatchNo:%v, ", *o.OutBatchNo)
	}

	if o.BatchId == nil {
		ret += "BatchId:<nil>, "
	} else {
		ret += fmt.Sprintf("BatchId:%v, ", *o.BatchId)
	}

	if o.Appid == nil {
		ret += "Appid:<nil>, "
	} else {
		ret += fmt.Sprintf("Appid:%v, ", *o.Appid)
	}

	if o.OutDetailNo == nil {
		ret += "OutDetailNo:<nil>, "
	} else {
		ret += fmt.Sprintf("OutDetailNo:%v, ", *o.OutDetailNo)
	}

	if o.DetailId == nil {
		ret += "DetailId:<nil>, "
	} else {
		ret += fmt.Sprintf("DetailId:%v, ", *o.DetailId)
	}

	if o.DetailStatus == nil {
		ret += "DetailStatus:<nil>, "
	} else {
		ret += fmt.Sprintf("DetailStatus:%v, ", *o.DetailStatus)
	}

	if o.TransferAmount == nil {
		ret += "TransferAmount:<nil>, "
	} else {
		ret += fmt.Sprintf("TransferAmount:%v, ", *o.TransferAmount)
	}

	if o.TransferRemark == nil {
		ret += "TransferRemark:<nil>, "
	} else {
		ret += fmt.Sprintf("TransferRemark:%v, ", *o.TransferRemark)
	}

	if o.Openid == nil {
		ret += "Openid:<nil>, "
	} else {
		ret += fmt.Sprintf("Openid:%v, ", *o.Openid)
	}

	if o.Username == nil {
		ret += "Username:<nil>, "
	} else {
		ret += fmt.Sprintf("Username:%v, ", *o.Username)
	}

	if o.InitiateTime == nil {
		ret += "InitiateTime:<nil>, "
	} else {
		ret += fmt.Sprintf("InitiateTime:%v, ", *o.InitiateTime)
	}

	if o.UpdateTime == nil {
		ret += "UpdateTime:<nil>, "
	} else {
		ret += fmt.Sprintf("UpdateTime:%v, ", *o.UpdateTime)
	}

	if o.BankName == nil {
		ret += "BankName:<nil>, "
	} else {
		ret += fmt.Sprintf("BankName:%v, ", *o.BankName)
	}

	if o.BankCardNumberTail == nil {
		ret += "BankCardNumberTail:<nil>, "
	} else {
		ret += fmt.Sprintf("BankCardNumberTail:%v, ", *o.BankCardNumberTail)
	}

	if o.AccountType == nil {
		ret += "AccountType:<nil>, "
	} else {
		ret += fmt.Sprintf("AccountType:%v, ", *o.AccountType)
	}

	if o.FailReason == nil {
		ret += "FailReason:<nil>"
	} else {
		ret += fmt.Sprintf("FailReason:%v", *o.FailReason)
	}

	return fmt.Sprintf("TransferDetailEntity{%s}", ret)
}

func (o TransferDetailEntity) Clone() *TransferDetailEntity {
	ret := TransferDetailEntity{}

	if o.SpMchid != nil {
		ret.SpMchid = new(string)
		*ret.SpMchid = *o.SpMchid
	}

	if o.OutBatchNo != nil {
		ret.OutBatchNo = new(string)
		*ret.OutBatchNo = *o.OutBatchNo
	}

	if o.BatchId != nil {
		ret.BatchId = new(string)
		*ret.BatchId = *o.BatchId
	}

	if o.Appid != nil {
		ret.Appid = new(string)
		*ret.Appid = *o.Appid
	}

	if o.OutDetailNo != nil {
		ret.OutDetailNo = new(string)
		*ret.OutDetailNo = *o.OutDetailNo
	}

	if o.DetailId != nil {
		ret.DetailId = new(string)
		*ret.DetailId = *o.DetailId
	}

	if o.DetailStatus != nil {
		ret.DetailStatus = new(string)
		*ret.DetailStatus = *o.DetailStatus
	}

	if o.TransferAmount != nil {
		ret.TransferAmount = new(int64)
		*ret.TransferAmount = *o.TransferAmount
	}

	if o.TransferRemark != nil {
		ret.TransferRemark = new(string)
		*ret.TransferRemark = *o.TransferRemark
	}

	if o.Openid != nil {
		ret.Openid = new(string)
		*ret.Openid = *o.Openid
	}

	if o.Username != nil {
		ret.Username = new(string)
		*ret.Username = *o.Username
	}

	if o.InitiateTime != nil {
		ret.InitiateTime = new(time.Time)
		*ret.InitiateTime = *o.InitiateTime
	}

	if o.UpdateTime != nil {
		ret.UpdateTime = new(time.Time)
		*ret.UpdateTime = *o.UpdateTime
	}

	if o.BankName != nil {
		ret.BankName = new(string)
		*ret.BankName = *o.BankName
	}

	if o.BankCardNumberTail != nil {
		ret.BankCardNumberTail = new(string)
		*ret.BankCardNumberTail = *o.BankCardNumberTail
	}

	if o.AccountType != nil {
		ret.AccountType = new(PayeeAccountType)
		*ret.AccountType = *o.AccountType
	}

	if o.FailReason != nil {
		ret.FailReason = new(FailReasonType)
		*ret.FailReason = *o.FailReason
	}

	return &ret
}

// TransferDetailInput
type TransferDetailInput struct {
	// 商户系统内部区分转账批次单下不同转账明细单的唯一标识
	OutDetailNo *string `json:"out_detail_no"`
	// 转账金额单位为“分”
	TransferAmount *int64 `json:"transfer_amount"`
	// 单条转账备注（微信用户会收到该备注），UTF8编码，最多允许32个字符
	TransferRemark *string `json:"transfer_remark"`
	// 收款用户openid。如果转账特约商户授权类型是INFORMATION_AUTHORIZATION_TYPE，对应的是特约商户公众号下的openid。
	Openid *string `json:"openid"`
	// 收款用户姓名。采用标准RSA算法，公钥由微信侧提供 明细转账金额 >= 2,000时，该笔明细必须填写收款用户姓名 同一批次转账明细中的姓名字段传入规则需保持一致，也即全部填写、或全部不填写 若商户传入收款用户姓名，微信支付会校验用户openID与姓名是否一致，并提供电子回单
	UserName *string `json:"user_name,omitempty" encryption:"EM_APIV3"`
	// 收款方身份证号，可不用填（采用标准RSA算法，公钥由微信侧提供） 当填入收款方身份证号时，姓名字段必须填入
	UserIdCard *string `json:"user_id_card,omitempty" encryption:"EM_APIV3"`
}

func (o TransferDetailInput) MarshalJSON() ([]byte, error) {
	toSerialize := map[string]interface{}{}

	if o.OutDetailNo == nil {
		return nil, fmt.Errorf("field `OutDetailNo` is required and must be specified in TransferDetailInput")
	}
	toSerialize["out_detail_no"] = o.OutDetailNo

	if o.TransferAmount == nil {
		return nil, fmt.Errorf("field `TransferAmount` is required and must be specified in TransferDetailInput")
	}
	toSerialize["transfer_amount"] = o.TransferAmount

	if o.TransferRemark == nil {
		return nil, fmt.Errorf("field `TransferRemark` is required and must be specified in TransferDetailInput")
	}
	toSerialize["transfer_remark"] = o.TransferRemark

	if o.Openid == nil {
		return nil, fmt.Errorf("field `Openid` is required and must be specified in TransferDetailInput")
	}
	toSerialize["openid"] = o.Openid

	if o.UserName != nil {
		toSerialize["user_name"] = o.UserName
	}

	if o.UserIdCard != nil {
		toSerialize["user_id_card"] = o.UserIdCard
	}
	return json.Marshal(toSerialize)
}

func (o TransferDetailInput) String() string {
	var ret string
	if o.OutDetailNo == nil {
		ret += "OutDetailNo:<nil>, "
	} else {
		ret += fmt.Sprintf("OutDetailNo:%v, ", *o.OutDetailNo)
	}

	if o.TransferAmount == nil {
		ret += "TransferAmount:<nil>, "
	} else {
		ret += fmt.Sprintf("TransferAmount:%v, ", *o.TransferAmount)
	}

	if o.TransferRemark == nil {
		ret += "TransferRemark:<nil>, "
	} else {
		ret += fmt.Sprintf("TransferRemark:%v, ", *o.TransferRemark)
	}

	if o.Openid == nil {
		ret += "Openid:<nil>, "
	} else {
		ret += fmt.Sprintf("Openid:%v, ", *o.Openid)
	}

	if o.UserName == nil {
		ret += "UserName:<nil>, "
	} else {
		ret += fmt.Sprintf("UserName:%v, ", *o.UserName)
	}

	if o.UserIdCard == nil {
		ret += "UserIdCard:<nil>"
	} else {
		ret += fmt.Sprintf("UserIdCard:%v", *o.UserIdCard)
	}

	return fmt.Sprintf("TransferDetailInput{%s}", ret)
}

func (o TransferDetailInput) Clone() *TransferDetailInput {
	ret := TransferDetailInput{}

	if o.OutDetailNo != nil {
		ret.OutDetailNo = new(string)
		*ret.OutDetailNo = *o.OutDetailNo
	}

	if o.TransferAmount != nil {
		ret.TransferAmount = new(int64)
		*ret.TransferAmount = *o.TransferAmount
	}

	if o.TransferRemark != nil {
		ret.TransferRemark = new(string)
		*ret.TransferRemark = *o.TransferRemark
	}

	if o.Openid != nil {
		ret.Openid = new(string)
		*ret.Openid = *o.Openid
	}

	if o.UserName != nil {
		ret.UserName = new(string)
		*ret.UserName = *o.UserName
	}

	if o.UserIdCard != nil {
		ret.UserIdCard = new(string)
		*ret.UserIdCard = *o.UserIdCard
	}

	return &ret
}

// TransferScene   ORDINARY_TRANSFER - 普通转账，普通转账（默认）  PAYROLL_CARD_TRANSFER - 务工卡转账，给使用微信务工卡的用户进行转账
type TransferScene string

func (e TransferScene) Ptr() *TransferScene {
	return &e
}

// Enums of TransferScene
const (
	TRANSFERSCENE_ORDINARY_TRANSFER     TransferScene = "ORDINARY_TRANSFER"
	TRANSFERSCENE_PAYROLL_CARD_TRANSFER TransferScene = "PAYROLL_CARD_TRANSFER"
)

// TransferUseType   GOODSPAYMENT - 货款， 给用户支付货物采购资金  COMMISSION - 佣金，给用户支付业务推广佣金  REFUND - 退款，给用户支付交易退款  REIMBURSEMENT - 报销，企业给员工支付差旅等报销资金  FREIGHT - 运费，给司机支付运输费用  OTHERS - 其他，其他
type TransferUseType string

func (e TransferUseType) Ptr() *TransferUseType {
	return &e
}

// Enums of TransferUseType
const (
	TRANSFERUSETYPE_GOODSPAYMENT  TransferUseType = "GOODSPAYMENT"
	TRANSFERUSETYPE_COMMISSION    TransferUseType = "COMMISSION"
	TRANSFERUSETYPE_REFUND        TransferUseType = "REFUND"
	TRANSFERUSETYPE_REIMBURSEMENT TransferUseType = "REIMBURSEMENT"
	TRANSFERUSETYPE_FREIGHT       TransferUseType = "FREIGHT"
	TRANSFERUSETYPE_OTHERS        TransferUseType = "OTHERS"
)
